<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>R4N</title>
  <link rel="icon" type="image/png" href="assets/icon.png">

  <style>
    :root{
      --bg:#fefefe;
      --fg:#111111;
      --muted:rgba(17,17,17,0.65);
      --select: rgba(17,17,17,0.55);
    }

    *{margin:0;padding:0;box-sizing:border-box;}

    body{
      background:var(--bg);
      color:var(--fg);
      min-height:100vh;
      overflow:hidden;
      position:relative;

      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      font-size:13px;
      font-weight:400;
      letter-spacing:0.2px;
    }

    .logo{
      width:100%;
      display:flex;
      justify-content:center;
      padding-top:0px;
      margin-top:-6px;
      position:relative;
      z-index:5;
    }
    .logo a{display:inline-flex;text-decoration:none;}
    .logo img{
      width:136px;
      height:136px;
      object-fit:contain;
      display:block;
    }
    @media (max-width: 768px){
      .logo{
        height:78px;
        padding-top:2px;
        margin-top:0;
        align-items:center;
      }
    }

    .drag{
      position:absolute;
      z-index:10;
      user-select:none;
      cursor:grab;
      text-align:center;
      padding:10px;
      border-radius:0;
      touch-action:none;
      visibility:hidden;
    }
    .drag.ready{ visibility:visible; }
    .drag:active{cursor:grabbing;}

    .drag.is-dragging{
      outline:none;
      border-radius:0;
    }
    .drag.is-dragging::after{
      content:"";
      position:absolute;
      inset:0;
      border:2px dotted var(--select);
      pointer-events:none;
      border-radius:0;
    }

    .drag img{
      width:70px;
      height:70px;
      object-fit:contain;
      display:block;
      margin:0 auto;
      filter:drop-shadow(0 6px 18px rgba(0,0,0,0.14));
      opacity:0.92;
      transition:transform 0.15s ease, opacity 0.15s ease;
    }
    .drag:hover img{transform:scale(1.03);opacity:1;}

    .label{
      margin-top:10px;
      text-transform:uppercase;
      color:var(--muted);
      letter-spacing:1.8px;
    }

    .socials{
      position:fixed;
      left:50%;
      bottom:36px;
      transform:translateX(-50%);
      z-index:50;
      color:var(--muted);
      font-size:12px;
      letter-spacing:0.4px;
      user-select:none;
      white-space:nowrap;
    }
    .socials a{ color:inherit; text-decoration:none; }
    .socials a:hover{ color:rgba(17,17,17,0.9); }

    a{color:inherit;-webkit-tap-highlight-color:transparent;}
  </style>
</head>

<body>
  <div class="logo" id="logoBlock">
    <a href="./" aria-label="Home">
      <!-- Fallback: if your images aren't inside /assets, this will still work -->
      <img src="assets/logo.png" alt="Logo" onerror="this.onerror=null;this.src='logo.png';">
    </a>
  </div>

  <a href="projects/" id="projectsLink" aria-label="Projects">
    <div class="drag" id="projectsBtn" data-store-key="index:projects">
      <img src="assets/file.png" alt="Projects" onerror="this.onerror=null;this.src='file.png';">
      <div class="label">PROJECTS</div>
    </div>
  </a>

  <a href="new/index.html" id="mysteryLink" aria-label="???">
    <div class="drag" id="mysteryBtn" data-store-key="index:mystery">
      <img src="assets/new.png" alt="???" onerror="this.onerror=null;this.src='new.png';">
      <div class="label">???</div>
    </div>
  </a>

  <div class="socials" aria-label="Social links">
    <a href="https://www.instagram.com/r4n.wav/" target="_blank" rel="noopener">instagram</a>
    &nbsp;/&nbsp;
    <a href="https://open.spotify.com/artist/2RhtCG7SVNhfYCBHkpFvFr" target="_blank" rel="noopener">spotify</a>
    &nbsp;/&nbsp;
    <a href="mailto:r4nmusic@outlook.com">contact</a>
  </div>

  <script>
    // ---------- layering ----------
    let zCounter = 60;
    function bringToFront(el){
      zCounter += 1;
      el.style.zIndex = String(zCounter);
    }

    // ---------- storage ----------
    function getStored(key){
      try { return JSON.parse(localStorage.getItem(key) || "null"); }
      catch { return null; }
    }
    function setStored(key, val){
      localStorage.setItem(key, JSON.stringify(val));
    }

    function setElPos(el, x, y){
      el.style.left = `${x}px`;
      el.style.top  = `${y}px`;
    }

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    function clampToViewport(el, x, y){
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const w  = el.offsetWidth;
      const h  = el.offsetHeight;
      return { x: clamp(x, 0, vw - w), y: clamp(y, 0, vh - h) };
    }


    // ---------- positioning safety (avoid logo/socials + avoid overlapping buttons) ----------
    function rectsOverlap(a, b, pad = 0){
      return !(
        (a.right  + pad) <= b.left  ||
        (a.left   - pad) >= b.right ||
        (a.bottom + pad) <= b.top   ||
        (a.top    - pad) >= b.bottom
      );
    }

    function rectForElAt(el, x, y){
      return { left:x, top:y, right:x + el.offsetWidth, bottom:y + el.offsetHeight };
    }

    function getForbiddenRects(pad = 18){
      const out = [];
      const logo = document.getElementById("logoBlock");
      const socials = document.querySelector(".socials");
      if (logo){
        const r = logo.getBoundingClientRect();
        out.push({ left:r.left - pad, top:r.top - pad, right:r.right + pad, bottom:r.bottom + pad });
      }
      if (socials){
        const r = socials.getBoundingClientRect();
        out.push({ left:r.left - pad, top:r.top - pad, right:r.right + pad, bottom:r.bottom + pad });
      }
      return out;
    }

    function resolveSafePosition(el, x, y, avoidEls = [], forbiddenRects = [], pad = 14){
      // Iteratively nudge down / sideways until it doesn't overlap forbidden areas or other buttons.
      let pos = clampToViewport(el, x, y);
      let tries = 0;

      while (tries < 60){
        const r = rectForElAt(el, pos.x, pos.y);

        // Forbidden areas first
        let hit = forbiddenRects.find(fr => rectsOverlap(r, fr, 0));
        if (hit){
          // Push below the forbidden rect if we are intersecting it; otherwise nudge sideways.
          const pushDown = hit.bottom + pad;
          pos = clampToViewport(el, pos.x, pushDown);
          tries++;
          continue;
        }

        // Other draggable buttons
        let otherHit = null;
        for (const other of avoidEls){
          if (!other || other === el) continue;
          const orc = other.getBoundingClientRect();
          const obr = { left:orc.left, top:orc.top, right:orc.right, bottom:orc.bottom };
          if (rectsOverlap(r, obr, pad)){
            otherHit = obr;
            break;
          }
        }
        if (otherHit){
          // Stack it below the other button (keeps them close but not overlapping).
          const pushDown = otherHit.bottom + pad;
          pos = clampToViewport(el, pos.x, pushDown);

          // If we hit the bottom, try nudging sideways a bit.
          if (pos.y >= window.innerHeight - el.offsetHeight - 1){
            pos = clampToViewport(el, pos.x + (el.offsetWidth * 0.6), pos.y - (el.offsetHeight * 0.6));
          }
          tries++;
          continue;
        }

        break; // safe
      }

      return pos;
    }

    // ---------- draggable (with orbital easter egg) ----------
    function makeDraggable(el, linkEl, opts = {}){
      const storeKey = el.dataset.storeKey;
      const avoidEls = opts.avoidEls ?? [];
      const forbiddenRectsFn = opts.forbiddenRectsFn ?? (() => getForbiddenRects(opts.forbiddenPad ?? 18));
      const safePad = opts.safePad ?? 14;

      let dragging = false;
      let startX = 0, startY = 0;
      let offsetX = 0, offsetY = 0;
      let movedEnough = false;
      const MOVE_THRESHOLD = opts.moveThreshold ?? 6;

      // Trigger: >=20 turns within 8 seconds (ovals OK)
      const ORBIT_WINDOW_MS = 8000;
      const ORBIT_TARGET_TURNS = 20;
      const MIN_POINTS = 90;
      const MAX_POINTS = 1800;

      // Energy-based orbit speed (fast)
      const ENERGY_SCALE = opts.energyScale ?? 0.95;
      const OMEGA_MIN = opts.omegaMin ?? 5.0;
      const OMEGA_MAX = opts.omegaMax ?? 22.0;
      const ORBIT_STOP_SPEED = opts.orbitStopSpeed ?? 0.30;
      const ORBIT_STOP_AFTER_SEC = opts.orbitStopAfterSec ?? 10;

      // Ellipse fit: keep it close to user's path (no "bonus" scaling)
      const AXIS_ENVELOPE = opts.axisEnvelope ?? 1.0; // 1.0 = do not inflate

      let orbitArmed = true;
      let orbitMode = false;
      let orbitAnimRaf = null;

      let samples = []; // {t,x,y}
      let orbitModel = null; // {cx,cy,u,v,a,b,phase,omega,k}

      function now(){ return performance.now(); }

      function recordSample(x, y){
        const t = now();
        samples.push({ t, x, y });
        if (samples.length > MAX_POINTS) samples.shift();

        const cutoff = t - ORBIT_WINDOW_MS;
        while (samples.length && samples[0].t < cutoff) samples.shift();
      }

      function meanXY(pts){
        let sx = 0, sy = 0;
        for (const p of pts){ sx += p.x; sy += p.y; }
        const n = pts.length || 1;
        return { cx: sx / n, cy: sy / n };
      }

      function unwrapAngles(angles){
        if (angles.length === 0) return angles;
        const out = [angles[0]];
        for (let i = 1; i < angles.length; i++){
          const a = angles[i];
          const prev = out[i-1];
          const basePrev = prev % (Math.PI * 2);
          let da = a - basePrev;
          while (da > Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          out.push(prev + da);
        }
        return out;
      }

      function fitEllipsePCA(pts, cx, cy){
        // Covariance of centered points
        let sxx = 0, sxy = 0, syy = 0;
        const n = pts.length || 1;
        for (const p of pts){
          const dx = p.x - cx;
          const dy = p.y - cy;
          sxx += dx * dx;
          sxy += dx * dy;
          syy += dy * dy;
        }
        sxx /= n; sxy /= n; syy /= n;

        // Eigen decomposition of [[sxx,sxy],[sxy,syy]]
        const trace = sxx + syy;
        const det = sxx * syy - sxy * sxy;
        const disc = Math.max(0, trace * trace - 4 * det);
        const root = Math.sqrt(disc);
        const l1 = (trace + root) / 2;

        // Major eigenvector
        let ux, uy;
        if (Math.abs(sxy) > 1e-9){
          ux = l1 - syy;
          uy = sxy;
        } else {
          ux = (sxx >= syy) ? 1 : 0;
          uy = (sxx >= syy) ? 0 : 1;
        }
        const un = Math.hypot(ux, uy) || 1;
        ux /= un; uy /= un;

        const vx = -uy;
        const vy = ux;

        // RMS along axes
        let su2 = 0, sv2 = 0;
        for (const p of pts){
          const dx = p.x - cx;
          const dy = p.y - cy;
          const pu = dx * ux + dy * uy;
          const pv = dx * vx + dy * vy;
          su2 += pu * pu;
          sv2 += pv * pv;
        }
        su2 /= n; sv2 /= n;

        // Convert RMS to a representative ellipse envelope (no inflation by default)
        const a = Math.max(12, Math.sqrt(2 * su2) * AXIS_ENVELOPE);
        const b = Math.max(12, Math.sqrt(2 * sv2) * AXIS_ENVELOPE);

        return { u:{x:ux,y:uy}, v:{x:vx,y:vy}, a, b };
      }

      function ellipsePoint(phase){
        const ct = Math.cos(phase);
        const st = Math.sin(phase);
        const x = orbitModel.cx + orbitModel.a * ct * orbitModel.u.x + orbitModel.b * st * orbitModel.v.x;
        const y = orbitModel.cy + orbitModel.a * ct * orbitModel.u.y + orbitModel.b * st * orbitModel.v.y;
        return { x, y };
      }

      function stopOrbit(){
        orbitMode = false;
        if (orbitAnimRaf) cancelAnimationFrame(orbitAnimRaf);
        orbitAnimRaf = null;
        orbitModel = null;

        // allow link to be clickable again unless currently dragging
        if (!dragging) {
          setTimeout(() => { delete linkEl.dataset.dragging; }, 0);
        }
        el.style.cursor = dragging ? "grabbing" : "grab";
      }

      function tryTriggerOrbit(){
        if (!opts.enableOrbitEgg) return false;
        if (!orbitArmed || orbitMode) return false;
        if (samples.length < MIN_POINTS) return false;

        const pts = samples;
        const { cx, cy } = meanXY(pts);

        // Count turns around centroid
        const anglesRaw = [];
        const times = [];
        for (const p of pts){
          anglesRaw.push(Math.atan2(p.y - cy, p.x - cx));
          times.push(p.t);
        }
        const unwrapped = unwrapAngles(anglesRaw);

        // Direction consistency + total turns
        let pos = 0, neg = 0;
        for (let i = 1; i < unwrapped.length; i++){
          const d = unwrapped[i] - unwrapped[i-1];
          if (d > 0) pos++;
          else if (d < 0) neg++;
        }
        const dirTotal = pos + neg;
        if (dirTotal < 8) return false;

        const dirCons = Math.max(pos, neg) / dirTotal;
        if (dirCons < 0.70) return false;

        const totalTurns = Math.abs((unwrapped[unwrapped.length - 1] - unwrapped[0]) / (Math.PI * 2));
        if (totalTurns < ORBIT_TARGET_TURNS) return false;

        // Energy from gesture (angular velocity)
        const dt = Math.max(0.06, (times[times.length - 1] - times[0]) / 1000);
        const dtheta = unwrapped[unwrapped.length - 1] - unwrapped[0];
        const omegaUser = (dtheta / dt) * ENERGY_SCALE;

        let omega0 = clamp(omegaUser, -OMEGA_MAX, OMEGA_MAX);
        if (Math.abs(omega0) < OMEGA_MIN) omega0 = Math.sign(omega0 || 1) * OMEGA_MIN;

        // Fit ellipse close to the user path
        const fit = fitEllipsePCA(pts, cx, cy);

        // Make sure orbit starts EXACTLY where the user is holding it (no jump):
        // scale ellipse uniformly so the current point lies on the ellipse.
        const rect = el.getBoundingClientRect();
        const curX = rect.left + rect.width / 2;
        const curY = rect.top  + rect.height / 2;

        const dx = curX - cx;
        const dy = curY - cy;
        const pu = dx * fit.u.x + dy * fit.u.y;
        const pv = dx * fit.v.x + dy * fit.v.y;

        // Current point in normalized ellipse coords:
        const nu = pu / fit.a;
        const nv = pv / fit.b;
        const s = Math.sqrt(nu*nu + nv*nv) || 1;
        // If s != 1, scale a & b so the ellipse passes through the current point.
        fit.a *= s;
        fit.b *= s;

        // Start phase so the ellipse point matches current point (now it will)
        const pu2 = pu / fit.a;
        const pv2 = pv / fit.b;
        const phase0 = Math.atan2(pv2, pu2);

        // Damping constant: reach stop speed around ORBIT_STOP_AFTER_SEC
        const k = Math.log(Math.abs(omega0) / ORBIT_STOP_SPEED) / Math.max(1, ORBIT_STOP_AFTER_SEC);

        orbitModel = {
          cx, cy,
          u: fit.u,
          v: fit.v,
          a: fit.a,
          b: fit.b,
          phase: phase0,
          omega: omega0,
          k
        };

        enableOrbitMode();
        return true;
      }

      function enableOrbitMode(){
        orbitMode = true;
        orbitArmed = false;

        el.classList.remove("is-dragging");
        el.style.cursor = "default";
        linkEl.dataset.dragging = "1";

        let lastT = now();
        function tick(){
          if (!orbitMode) return;

          const t = now();
          const dt = Math.min(0.05, (t - lastT) / 1000);
          lastT = t;

          // Exponential damping
          const damp = Math.exp(-orbitModel.k * dt);
          orbitModel.omega *= damp;

          if (Math.abs(orbitModel.omega) < ORBIT_STOP_SPEED){
            stopOrbit();

            // Persist final resting spot
            const left = parseFloat(el.style.left || "0");
            const top  = parseFloat(el.style.top  || "0");
            const snapped = clampToViewport(el, left, top);
            setElPos(el, snapped.x, snapped.y);
            setStored(storeKey, snapped);
            return;
          }

          orbitModel.phase += orbitModel.omega * dt;

          const p = ellipsePoint(orbitModel.phase);

          const halfW = el.offsetWidth / 2;
          const halfH = el.offsetHeight / 2;
          let x = p.x - halfW;
          let y = p.y - halfH;

          const snapped = clampToViewport(el, x, y);
          setElPos(el, snapped.x, snapped.y);

          orbitAnimRaf = requestAnimationFrame(tick);
        }

        orbitAnimRaf = requestAnimationFrame(tick);
      }

      function pointerDown(e){
        // Allow grabbing while orbiting: stop orbit immediately and return to normal drag behavior.
        if (orbitMode){
          stopOrbit();
        }

        dragging = true;
        movedEnough = false;
        orbitArmed = true;
        samples = [];

        bringToFront(el);
        el.setPointerCapture?.(e.pointerId);

        const rect = el.getBoundingClientRect();
        startX = e.clientX; startY = e.clientY;
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        el.classList.add("is-dragging");
        el.style.cursor = "grabbing";
        e.preventDefault();
      }

      function pointerMove(e){
        if (!dragging) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        if (!movedEnough && Math.hypot(dx, dy) > MOVE_THRESHOLD) {
          movedEnough = true;
          linkEl.dataset.dragging = "1";
        }

        setElPos(el, e.clientX - offsetX, e.clientY - offsetY);

        if (opts.enableOrbitEgg && movedEnough){
          const rect = el.getBoundingClientRect();
          const cx = rect.left + rect.width / 2;
          const cy = rect.top  + rect.height / 2;
          recordSample(cx, cy);
          tryTriggerOrbit();
        }

        e.preventDefault();
      }

      function pointerUp(){
        if (!dragging) return;
        dragging = false;

        el.classList.remove("is-dragging");
        el.style.cursor = "grab";

        const left = parseFloat(el.style.left || "0");
        const top  = parseFloat(el.style.top  || "0");
        let snapped = clampToViewport(el, left, top);
        // After the user drags, allow overlapping/stacking with other buttons.
        // Still keep it inside the viewport and away from logo/socials.
        snapped = resolveSafePosition(el, snapped.x, snapped.y, [], forbiddenRectsFn(), safePad);

        setElPos(el, snapped.x, snapped.y);
        setStored(storeKey, snapped);

        setTimeout(() => { delete linkEl.dataset.dragging; }, 0);
      }

      linkEl.addEventListener("click", (e) => {
        if (linkEl.dataset.dragging === "1") {
          e.preventDefault();
          e.stopPropagation();
        }
      });

      el.addEventListener("pointerdown", pointerDown);
      window.addEventListener("pointermove", pointerMove, { passive:false });
      window.addEventListener("pointerup", pointerUp, { passive:false });

      function initPos(defaultX, defaultY){
        const saved = getStored(storeKey);

        // If the user already positioned it before, restore that exact position (only clamp to viewport).
        // If it's the first visit, place it safely (avoid logo/socials + other floating buttons).
        if (saved){
          const snapped = clampToViewport(el, saved.x, saved.y);
          setElPos(el, snapped.x, snapped.y);
          setStored(storeKey, snapped);
        } else {
          const raw = { x: defaultX, y: defaultY };
          let snapped = clampToViewport(el, raw.x, raw.y);
          snapped = resolveSafePosition(el, snapped.x, snapped.y, avoidEls, forbiddenRectsFn(), safePad);
          setElPos(el, snapped.x, snapped.y);
          setStored(storeKey, snapped);
        }

        bringToFront(el);
        el.classList.add("ready");
        el.style.cursor = "grab";
      }

      window.addEventListener("resize", () => {
        const left = parseFloat(el.style.left || "0");
        const top  = parseFloat(el.style.top  || "0");
        let snapped = clampToViewport(el, left, top);
        // Keep resize from forcing buttons apart; allow stacking.
        snapped = resolveSafePosition(el, snapped.x, snapped.y, [], forbiddenRectsFn(), safePad);
        setElPos(el, snapped.x, snapped.y);
        setStored(storeKey, snapped);
      });

      return { initPos, el, linkEl, storeKey };
    }

    // ---------- init both floating buttons (non-overlapping on first load) ----------
    const floatingEls = [];

    const projectsDrag = makeDraggable(
      document.getElementById("projectsBtn"),
      document.getElementById("projectsLink"),
      {
        enableOrbitEgg: true,
        avoidEls: floatingEls
      }
    );

    const mysteryDrag = makeDraggable(
      document.getElementById("mysteryBtn"),
      document.getElementById("mysteryLink"),
      {
        enableOrbitEgg: true,
        avoidEls: floatingEls
      }
    );

    floatingEls.push(projectsDrag.el, mysteryDrag.el);
    document.addEventListener("DOMContentLoaded", () => {
      // base center placement, then the safety resolver will keep them away from logo/socials + each other.
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      const w1 = projectsDrag.el.offsetWidth;
      const h1 = projectsDrag.el.offsetHeight;

      const cx = (vw / 2) - (w1 / 2);
      const cy = Math.max(160, (vh / 2) - (h1 / 2));

      // Put them near each other but not overlapping on first entry.
      projectsDrag.initPos(cx - 90, cy);
      mysteryDrag.initPos(cx + 90, cy + 20);
    });
  </script>
</body>
</html>
